导致乱序执行的三种方式

1，编译器优化
编译器会对代码进行重排序，只要在不影响代码结果的情况下，编译器可以以任意一种方式对代码进行编译。(重排序优化)
编译器还会把一些变量放到寄存器中，避免每次都访问内存。(指令优化)
编译器的本意是提升程序在CPU上的运行性能，更好的使用寄存器以及现代处理器的流水线技术，减少汇编指令的数量，降低程序执行需要的CPU周期，减少CPU读写主存的时间。

问题解决：
volatile关键字：每次访问不能通过寄存器。禁止重排序优化
编译器屏障：禁止编译屏障前后编译器对于变量操作的优化（重排序、从寄存器中取值使用）
#define barrier() __asm__ __volatile__("": : :"memory")
这段代码的意思是告诉编译器“内存发生了改变”，因此GCC编译时就会知道，不能使用寄存器中的值，而是要去内存中取值，且不能将屏障前后的代码重排序

2，处理器乱序执行
由于cpu指令流水线化的执行，会导致cpu乱序的执行指令。
一个指令的完整动作分割成多个子任务，如一个指令动作包括，取指、解码、执行、写回。
非流水线执行：指令按照顺序依次执行，而且在一个指令周期内，各个处理单元需要等待前面步骤完成，才能开始工作。
流水线执行：指令被乱序的执行，每个处理单元执行自己的子任务，各个处理单元充分的工作，提高了cpu的执行效率。
乱序执行：有的指令之间存在依赖关系，必须等待被依赖的指令完成，才能继续执行。在等待的时候。处理单元并没有空闲，可以乱序的执行可以执行的指令，这也就充分提高了cpu执行效率。


3，cpu缓存
缓存一致性协议：MESI
原理：cpu执行读写的时候，会在一定情况下往总线发送特定的请求消息，同时处理器还会拦截其他处理器发送的请求消息，并在一定情况下回应相应消息。能够做到并发读，互斥写。
缺陷：性能太慢，处理器每次写数据都得等其他处理器将自己cache的对应数据删除，并且接收到Read response和Invalidate acknowledge消息后才能执行写操作。
解决写(写每次都要发送无效消息，并且同步等待回应)：store buffer。先将写临时写到store buffer中，然后发送无效消息，不必同步等待回应。
解决读(cpu需要同步的处理各种消息)：无效队列。将发送来的消息缓存起来，不必每次同步处理。
问题：带来了重排序和可见性的问题。
解决：写屏障，先flush store buffer和处理完无效消息再执行后续操作。读屏障，先处理无效队列中的所有消息，再执行读。

乱序执行影响
在多线程程序中，由于乱序执行的原因，可能发生下面问题。
A：a=100;flag=true;
B: while(flag){
      c=a;  
   }
可能线程A乱序执行，先执行flag赋值，再执行a赋值，最后将导致线程B的c的值为0。
